%# BEGIN BPS TAGGED BLOCK {{{
%#
%# COPYRIGHT:
%#
%# This software is Copyright (c) 1996-2021 Best Practical Solutions, LLC
%#                                          <sales@bestpractical.com>
%#
%# (Except where explicitly superseded by other copyright notices)
%#
%#
%# LICENSE:
%#
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%#
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%#
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%#
%#
%# CONTRIBUTION SUBMISSION POLICY:
%#
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%#
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%#
%# END BPS TAGGED BLOCK }}}
<%PERL>
# Find all the attachments which have parent $Parent
# For each of these attachments
foreach my $message ( @{ $Attachments->{ $Parent || 0 } || [] } ) {
    $m->comp( 'ShowMessageHeaders',
              WarnUnsigned   => $WarnUnsigned,
              Message        => $message,
              DisplayHeaders => \@DisplayHeaders,
            );

    my $name = defined $message->Filename && length $message->Filename ?  $message->Filename : '';
    my $should_render_download = $message->ContentLength || $name;

    $m->callback(CallbackName => 'BeforeAttachment', ARGSRef => \%ARGS, Object => $Object, Transaction => $Transaction, Attachment => $message, Name => $name, ShouldRenderDownload => \$should_render_download);

    if ($should_render_download) {
</%PERL>
<div class="downloadattachment">
% if (my $url = RT->System->ExternalStorageURLFor($message)) {
<a href="<% $url %>"
% } else {
<a href="<% $AttachmentPath %>/<% $Transaction->Id %>/<% $message->Id %>/<% $name | un %>" target="_blank"
% }
% if ( length $name ) {  # download link with filename
% my $download_alt = loc( 'Download [_1] [_2]', $message->ContentType, $message->FriendlyContentLength );
alt="<% $download_alt %>" data-toggle="tooltip" data-placement="bottom" data-original-title="<% $download_alt %>">
  <span class="fas fa-paperclip fa-2x"></span>
  <span class="downloadfilename"><% $name %></span>
</a>
% }
% else {  # view source and view source headers, without filename or size
% my $view_source_alt = loc( 'View source' );
>
  <span class="far fa-file fa-2x" alt="<% $view_source_alt %>" data-toggle="tooltip" data-placement="bottom" data-original-title="<% $view_source_alt %>"></span>
</a>
% if ( $DownloadableHeaders && ! length $name && $message->ContentType =~ /text/  ) {
% my $download_with_headers_alt = loc('View source with headers');
<a href="<% $AttachmentPath %>/WithHeaders/<% $message->Id %>" target="_blank">
  <span class="fa-stack" alt="<% $download_with_headers_alt %>" data-toggle="tooltip" data-placement="bottom" data-original-title="<% $download_with_headers_alt %>">
    <i class="far fa-file fa-stack-2x"></i>
    <i class="fas fa-plus fa-stack-1x"></i>
  </span>
</a>
% }
% }
% $m->callback(CallbackName => 'AfterDownloadLinks', ARGSRef => \%ARGS, Object => $Object, Transaction => $Transaction, Attachment => $message);
<br />
</div>
%   }
%# If there is sub-messages, open a dedicated div
% if ( $Attachments->{ $message->id } ) {
<div class="messageattachments">
% } else {
<div class="messagebody">
% }
<%PERL>

$render_attachment->( $message );

$m->comp(
    $m->current_comp,
    %ARGS,
    Parent    => $message->id,
    ParentObj => $message,

    displayed_inline => $displayed_inline,
);

</%PERL>
</div>
% }
<%ARGS>
$Transaction
$Object => $Transaction->Object
$ShowHeaders => 0
$DownloadableHeaders => 1
$AttachmentPath => undef
$Attachments => {}
$AttachmentContent => {}
$Parent => 0
$ParentObj => undef
$WarnUnsigned => 0

# Keep track of CID images we display inline
$displayed_inline => {}
</%ARGS>
<%INIT>
my @DisplayHeaders=qw(_all);
if ( $Transaction->Type =~ /EmailRecord$/ ) {
    @DisplayHeaders = qw(To Cc Bcc);
}

# If the transaction has anything attached to it at all
elsif (!$ShowHeaders)  {
    @DisplayHeaders = qw(To From RT-Send-Cc Cc Bcc RT-Attach Date Subject);
    push @DisplayHeaders, 'RT-Send-Bcc' if RT->Config->Get('ShowBccHeader');
}

$m->callback(CallbackName => 'MassageDisplayHeaders', DisplayHeaders => \@DisplayHeaders, Transaction => $Transaction, ShowHeaders => $ShowHeaders);

my $extract_cal_data;
$extract_cal_data = sub {
    # Notes on the VCALENDAR structure,
    # primary sources: RFCs 5545, 5546
    #   other RFCs may also apply

    #VCALENDAR
    # METHOD
    #   PUBLISH (no interactivity, probably can be ignored)
    #   REQUEST (interactive, looking for responses)
    #   REPLY (a response, conveying status)
    #   ADD (add instances to a recurring series)
    #   CANCEL (cancel one or more instances)
    #   REFRESH (used by an attendee to request an update, probably can be ignored)
    #   COUNTER (used to propose alternate times, probably can be ignored)
    #   DECLINECOUNTER (probably can be ignored)
    # CALSCALE - should be absent or GREGORIAN

    #VTIMEZONE
    # use https://metacpan.org/pod/DateTime::TimeZone::ICal ?
    # TZID - how it will be referred to later
    # DAYLIGHT
    #  DTSTART - irrelevant (start of timezone applicability?)
    #  RDATE, RRULE, TZNAME, TZOFFSETFROM, TZOFFSETTO
    # STANDARD
    #  DTSTART - irrelevant (start of timezone applicability?)
    #  RDATE, RRULE, TZNAME, TZOFFSETFROM, TZOFFSETTO

    # N.B. I've never seen an invite with multiple VTIMEZONE records, but it's not against the standard.
    #      Each non-UTC datetime MUST have a tzid, but because I've never seen more than one I'm
    #      not bothering to look at it.  This might be a problem for interpreting some attachments.

    #VEVENT
    # DTSTAMP - last-modified date/time
    # SEQUENCE - kind of like a DNS serial number
    # ORGANIZER
    #  CN - if present would be the name
    # SUMMARY
    # LOCATION
    # DESCRIPTION
    # RECURRENCE-ID - used when referring to a specific instance of a recurring event
    # DTSTART
    # DTEND / DURATION
    # EXDATE - exceptions to the recurrence rule
    # RDATE
    # RRULE

    my $into = shift; # hashref
    my $entry = shift; # Data::ICal::Entry object
    my $descr = shift || 'entry'; # used only in debugging
    my $indent = shift || '';     # used only in debugging
    my $parent_type = shift || undef;
    my $i;

    my $entry_type = $entry->ical_entry_type();

    #$m->out( $indent . $descr . " type: " . $entry_type . "\n" );

    my $properties = $entry->properties();

    if ($entry_type eq 'VCALENDAR' and exists $properties->{method}) {
        my $method = $properties->{method}[0]->value();

        if ($method eq 'REQUEST') {
            $into->{type} = loc('Meeting Invite');
        }
        elsif ($method eq 'CANCEL') {
            $into->{type} = loc('Meeting Cancellation');
        }
    }
    elsif ($entry_type eq 'VTIMEZONE' and exists $properties->{tzid}) {
        $into->{timezone_name} = $properties->{tzid}[0]->value();
    }
    elsif ($parent_type and $parent_type eq 'VTIMEZONE' and $entry_type =~ /^(STANDARD|DAYLIGHT)$/ and exists $properties->{tzoffsetto}) {
        my $offset_type = $1;

        my $value = $properties->{tzoffsetto}[0]->value();
        $value =~ s/(..)$/:$1/;
        $value =~ s/(\D)0/$1/;
        $value =~ s/:00$//;

        $into->{timezone_offset}{$offset_type} = $value;
    }
    elsif ($entry_type eq 'VEVENT') {
        foreach my $property_name (qw{organizer summary location description sequence dtstamp dtstart recurrence-id}) {
            if (exists $properties->{$property_name}) {
                $into->{$property_name} = $properties->{$property_name}[0]->value();
            }
        }

        if (exists $properties->{rrule}) {
            $into->{recurring} = 1;

            if (exists $properties->{exdate}) {
                $into->{exceptions} = 1;
            }
        }
    }

    #foreach my $prop_name ( sort keys %$properties ) {
    #    $i = 0;
    #    foreach my $prop ( @{ $properties->{$prop_name} } ) {
    #        $m->out( $indent . "    " . $prop_name . "[" . $i++ . "] = " . $prop->value() . "\n" );
    #        my $parameters = $prop->parameters();
    #        if ($parameters and keys %$parameters) {
    #            foreach my $param (sort keys %$parameters) {
    #                $m->out( $indent . "      " . $param . " = " . $parameters->{$param} . "\n" );
    #            }
    #        }
    #    }
    #}

    my $subentries = $entry->entries;

    $i = 0;
    foreach my $subentry (@$subentries) {
        $extract_cal_data->( $into, $subentry, $descr . "[" . $i++ . "]", $indent . "        ", $entry_type );
    }
};

my $render_attachment = sub {
    my $message = shift;
    my $name = defined $message->Filename && length $message->Filename ?  $message->Filename : '';

    my $content_type = lc $message->ContentType;

    # if it has a content-disposition: attachment, don't show inline
    my $disposition = $message->GetHeader('Content-Disposition');

    if ( $disposition && $disposition =~ /^\s*attachment/i ) {
        $disposition = 'attachment';
    } else {
        $disposition = 'inline';
    }

    my $max_size = RT->Config->Get( 'MaxInlineBody', $session{'CurrentUser'} );

    if ( $content_type eq 'text/calendar' ) {
        require Data::ICal;

        # A named attachment will already have a download button
        if (not $name) {
            $m->out('<div class="downloadattachment">');
            if (my $url = RT->System->ExternalStorageURLFor($message)) {
                $m->out('<a href="' . $url . '"');
            }
            else {
                $m->out('<a href="' . $AttachmentPath . '/' . $Transaction->Id . '/' . $message->Id . '/meeting.ics' . '" target="_blank"');
            }
            my $download_alt = loc( 'Download Meeting Invite' );
            $m->out('alt="' . $download_alt . '" data-toggle="tooltip" data-placement="bottom" data-original-title="' . $download_alt . '">');
            $m->out('<span class="fas fa-paperclip fa-2x"></span>');
            $m->out('<span class="downloadfilename">meeting.ics</span>');
            $m->out('</a>');
            $m->out('</div>');
        }

        if ( $disposition ne 'inline' ) {
            $m->out('<p>'. loc( 'Calendar invite is not shown because sender requested not to inline it.' ) .'</p>');
            return;
        }
        elsif ( $max_size && $message->ContentLength > $max_size ) {
            $m->out('<p>'. loc( 'Calendar invite is not shown because it is too large.' ) .'</p>');
            return;
        }

        my $content;
        # If we've cached the content, use it from there
        if (my $x = $AttachmentContent->{ $Transaction->id }->{$message->id}) {
            $content = $x->Content;
        }
        else {
            $content = $message->Content;
        }

        my $cal_item = Data::ICal->new(data => $content);

        if ( ref $cal_item and $cal_item->isa( 'Data::ICal::Entry' )) {
            local $Data::Dumper::Sortkeys = 1;
            local $Data::Dumper::Indent = 2;

            my %calendar_info = (
                location => loc('not given'),
                sequence => 0,
                type     => loc('Calendar Attachmet'),
            );

            $extract_cal_data->( \%calendar_info, $cal_item, 'Top Level Entry' );

            if (exists $calendar_info{timezone_name}) {
                my $offsets = join( '/', grep { defined $_ } @{$calendar_info{timezone_offset}}{ qw(STANDARD DAYLIGHT) } );

                if ($offsets) {
                    $calendar_info{timezone_text} = "$calendar_info{timezone_name} (UTC $offsets)";
                }
                else {
                    $calendar_info{timezone_text} = $calendar_info{timezone_name};
                }
            }

            foreach my $datetime ( qw(dtstamp dtstart) ) {
                # dates with a trailing 'Z' actually are in UTC while the other dates are in some
                # other timezine and the best we can do is to use their values unmodified, which
                # is most easily accomplished by using UTC.

                next unless exists $calendar_info{$datetime};

                my $date = RT::Date->new( $session{'CurrentUser'} );
                $date->Set(Format => 'iso', Value => $calendar_info{$datetime}, Timezone => 'UTC');

                if ($calendar_info{$datetime} =~ /Z$/) {
                    # explicitly in UTC, so we know when it is, so go ahead and present it in the user's timezone
                    $calendar_info{$datetime} = $date->AsString();
                }
                else {
                    $calendar_info{$datetime} = $date->AsString( Timezone => 'UTC' ) . ' ' . ($calendar_info{timezone_text} || loc("unknown timezone"));
                }
            }

            if ($calendar_info{organizer}) {
                $calendar_info{organizer} =~ s/^MAILTO://;
            }

            $m->out('<table><tbody>');
            $m->out('<tr>');
            $m->out('<td align="right" class="message-header-key">' . $calendar_info{type} . '</td>');
            $m->out('<td class="message-header-value">');
            if ($calendar_info{recurring}) {
                $m->out(loc('Recurring'));
                if ($calendar_info{exceptions}) {
                    $m->out(' ' . loc('with exceptions'));
                }
            }
            $m->out('</td>');
            $m->out('</tr>');
            $m->out('<tr>');
            $m->out('<td align="right" class="message-header-key">From:</td>');
            $m->out('<td class="message-header-value">' . $calendar_info{organizer} . '</td>');
            $m->out('</tr>');
            $m->out('<div class="message-stanza">');
            $m->out('<td align="right" class="message-header-key">Last Modified:</td>');
            $m->out('<td class="message-header-value">' . $calendar_info{dtstamp} . '</td>');
            $m->out('</tr>');
            $m->out('<div class="message-stanza">');
            $m->out('<td align="right" class="message-header-key">Subject:</td>');
            $m->out('<td class="message-header-value">' . $calendar_info{summary} . '</td>');
            $m->out('</tr>');
            $m->out('<div class="message-stanza">');
            $m->out('<td align="right" class="message-header-key">Location:</td>');
            $m->out('<td class="message-header-value">' . $calendar_info{location} . '</td>');
            $m->out('</tr>');
            $m->out('<div class="message-stanza">');
            $m->out('<td align="right" class="message-header-key">Starting:</td>');
            $m->out('<td class="message-header-value">' . $calendar_info{dtstart} . '</td>');
            $m->out('</tr>');
            $m->out('</tbody></table>');
            $m->out('<div class="messagebody">');
            $m->out(q{<div class="message-stanza-folder closed" onclick="fold_message_stanza(this, 'Show\x20full\x20description', 'Hide\x20full\x20description');">Show full description</div>});
            $m->out(qq{<div class="message-stanza closed"><div class="message-stanza plain-text-white-space">$calendar_info{description}</div></div>});
            $m->out('</div>');
        }

        return;
    }

    # If it's text
    elsif ( $content_type =~ m{^(text|message)/} ) {
        if ( $disposition ne 'inline' ) {
            $m->out('<p>'. loc( 'Message body is not shown because sender requested not to inline it.' ) .'</p>');
            return;
        }
        elsif ( length $name && RT->Config->Get('SuppressInlineTextFiles', $session{'CurrentUser'} ) ) {
            $m->out('<p>'. loc( 'Text file is not shown because it is disabled in preferences.' ) .'</p>');
            return;
        }
        elsif ( $max_size && $message->ContentLength > $max_size ) {
            $m->out('<p>'. loc( 'Message body is not shown because it is too large.' ) .'</p>');
            return;
        }

        if (

            # it's a toplevel object
            !$ParentObj

            # or its parent isn't a multipart alternative
            || ( $ParentObj->ContentType !~ m{^multipart/(?:alternative|related)$}i )

            # or it's of our prefered alterative type
            || (
                (
                    RT->Config->Get('PreferRichText', $session{CurrentUser})
                    && ( $content_type =~ m{^text/(?:html|enriched)$} )
                )
                || ( !RT->Config->Get('PreferRichText', $session{CurrentUser})
                    && ( $content_type !~ m{^text/(?:html|enriched)$} )
                )
            )
        ) {

            my $content;
            # If we've cached the content, use it from there
            if (my $x = $AttachmentContent->{ $Transaction->id }->{$message->id}) {
                $content = $x->Content;
            }
            else {
                $content = $message->Content;
            }

            $RT::Logger->debug(
                "Rendering attachment #". $message->id
                ." of '$content_type' type"
            );

            my $skip_quote_folding;
            $m->callback(
                CallbackName     => 'ModifyContent',
                ARGSRef          => \%ARGS,
                Object           => $Object,
                Transaction      => $Transaction,
                Content          => \$content,
                SkipQuoteFolding => \$skip_quote_folding,
            );

            # if it's a text/html clean the body and show it
            if ( $content_type eq 'text/html' ) {
                $content = $m->comp( '/Elements/ScrubHTML', Content => $content );

                if (RT->Config->Get('ShowTransactionImages')) {
                    my @rewritten = RT::Interface::Web::RewriteInlineImages(
                        Content         => \$content,
                        Attachment      => $message,
                        # Not technically correct to search all parts of the
                        # MIME structure, but it saves having to go to the
                        # database again and is unlikely to break display.
                        Related         => [ map { @$_ } values %$Attachments ],
                        AttachmentPath  => $AttachmentPath,
                    );
                    $displayed_inline->{$_}++ for @rewritten;
                }

                $m->comp(
                    '/Elements/MakeClicky',
                    content => \$content,
                    html    => 1,
                    object  => $Object,
                );

                if ( !$skip_quote_folding && !length $name && RT->Config->Get( 'QuoteFolding', $session{CurrentUser} ) ) {

                    eval {
                        require HTML::Quoted;
                        $content = HTML::Quoted->extract($content)
                    };
                    if ($@) {
                        RT->Logger->error(
                            "HTML::Quoted couldn't process attachment #@{[$message->id]}: $@."
                          . "  This is a bug, please report it to rt-bugs\@bestpractical.com.");
                    }
                }

                $m->comp(
                    'ShowMessageStanza',
                    Message     => $content,
                    Transaction => $Transaction,
                    ContentType => 'text/html',
                );
            }

            elsif ( $content_type eq 'text/enriched' ) {
                $content = $m->comp( '/Elements/ScrubHTML', Content => $content );
                $m->out( $content );
            }

            # It's a text type we don't have special handling for
            else {
                if ( !$skip_quote_folding && !length $name && RT->Config->Get( 'QuoteFolding', $session{CurrentUser} ) ) {
                    eval {
                        require Text::Quoted;
                        Text::Quoted::set_quote_characters(undef);
                        $content = Text::Quoted::extract($content);
                    };
                    if ($@) {
                        RT->Logger->error(
                            "Text::Quoted couldn't process attachment #@{[$message->id]}: $@."
                          . "  This is a bug, please report it to rt-bugs\@bestpractical.com.");
                    }
                }

                $m->comp(
                    'ShowMessageStanza',
                    Message     => $content,
                    Transaction => $Transaction,
                    ContentType => 'text/plain',
                );
            }
        }
    }

    # if it's an image, show it as an image
    elsif ( $content_type =~ m{^image/} ) {
        if (not RT->Config->Get('ShowTransactionImages')) {
            $m->out('<p><i>'. loc( 'Image not shown because display is disabled in system configuration.' ) .'</i></p>');
            return;
        }
        elsif ( $displayed_inline->{$message->Id} ) {
            $m->out('<p><i>'. loc( 'Image displayed inline above' ) .'</i></p>');
            return;
        }
        elsif ( $disposition ne 'inline' ) {
            $m->out('<p>'. loc( 'Image not shown because sender requested not to inline it.' ) .'</p>');
            return;
        }

        my $filename = length $name ? $name : loc('(untitled)');
        my $efilename = $m->interp->apply_escapes( $filename, 'h' );

        my $url = RT->System->ExternalStorageURLFor($message)
               || $AttachmentPath .'/'. $Transaction->Id .'/'. $message->Id .'/'
                . $m->interp->apply_escapes( $filename, 'u', 'h' );

        $m->out(
            qq{<img alt="$efilename" title="$efilename" src="$url" />}
        );
    }
    elsif ( $message->ContentLength && $message->ContentLength > 0 ) {
        $m->out( '<p>' .
            loc( 'Message body not shown because it is not plain text.' ) .
            '</p>'
        );
    }
};

</%INIT>
